using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using Moq;
using Stryker.Core.Initialisation;
using Stryker.Core.Mutants;
using Stryker.Core.Options;
using Stryker.Core.TestRunners;

namespace Stryker.Core.UnitTest.MutationTest
{
    /// <summary>
    /// This class simplifies the creation of run scenarios
    /// </summary>
    ///
    internal class FullRunScenario
    {
        // list of mutants
        private readonly Dictionary<int, Mutant> _mutants = new();
        // list of test (and their description)
        private readonly Dictionary<int, TestDescription> _tests = new ();
        // test coverage per mutant
        private readonly Dictionary<int, TestGuidsList> _coverageResult = new();
        // failing tests per mutant
        private readonly Dictionary<int, TestGuidsList> _failedTestsPerMutant = new();
        // mutant coverage per test
        private readonly Dictionary<Guid, List<int>> _testCoverage = new();
        // fine control: failing tests per mutant, taking into account the other mutants tested in the same session.
        private readonly Dictionary<HashSet<int>, Dictionary<int, TestGuidsList>> _failedTestsPerRun = new(new HashSetComparer());
        private OptimizationModes _mode = OptimizationModes.CoverageBasedTest | OptimizationModes.SkipUncoveredMutants;
        private const int InitialRunId = -1;
        private Mock<ITestRunner> _runnerMock;
        /// <summary>
        /// Existing tests.
        /// </summary>
        public TestSet TestSet { get; } = new();
        /// <summary>
        /// Existing mutants.
        /// </summary>
        public IDictionary<int, Mutant> Mutants => _mutants;

        /// <summary>
        /// Create a mutant
        /// </summary>
        /// <param name="mutantId">expected mutant Id, autogenerated by default</param>
        /// <returns>A mutant instance</returns>
        public Mutant CreateMutant(int mutantId = -1)
        {
            if (mutantId == -1)
            {
                mutantId = _mutants.Keys.Append(-1).Max() + 1;
            }
            var mutant = BuildMutant(mutantId);
            _mutants[mutantId] = mutant;
            return mutant;
        }

        public static Mutant BuildMutant(int id)
        {
            var mutant = new Mutant
            {
                Id = id,
                Mutation = new Mutation
                {
                    DisplayName = $"Test Mutation {id}.",
                    OriginalNode = SyntaxFactory.ParseStatement("return 1+2;"),
                    ReplacementNode = SyntaxFactory.ParseStatement("return 1-2;")
                }
            };
            return mutant;
        }

        /// <summary>
        /// Create several mutants using provided ids.
        /// </summary>
        /// <param name="mutantIds">list of desired mutants.</param>
        public void CreateMutants(params int[] mutantIds)
        {
            foreach (var id in mutantIds)
            {
                _ = CreateMutant(id);
            }
        }

        /// <summary>
        /// Get the list of mutants that must be tested.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<Mutant> GetCoveredMutants() => _coverageResult.Keys.Select(i => _mutants[i]);
        /// <summary>
        /// Get the status of the mutant of a given id
        /// </summary>
        /// <param name="mutantId">requested mutant id</param>
        /// <returns>return the mutant's status</returns>
        public MutantStatus GetMutantStatus(int mutantId) => _mutants[mutantId].ResultStatus;
        /// <summary>
        /// Declare the tests covering one mutant
        /// </summary>
        /// <param name="mutantId">mutant id</param>
        /// <param name="testIds">tests covering the given mutant</param>
        public void DeclareCoverageForMutant(int mutantId, params int[] testIds)
        {
            _coverageResult[mutantId] = GetGuidList(testIds);
            foreach (var testId in testIds)
            {
                var id = _tests[testId].Id;
                if (!_testCoverage.ContainsKey(id))
                {
                    _testCoverage[id] = new List<int>();
                }
                _testCoverage[id].Add(mutantId);
            }
        }

        /// <summary>
        /// Declare that the mutant must be run against all tests.
        /// </summary>
        /// <param name="mutantId">mutant id</param>
        public void DeclareFullCoverageForMutant(int mutantId) =>
            DeclareCoverageForMutant(mutantId, _tests.Keys.ToArray());
        /// <summary>
        /// Declare tests that are failing against the non mutated assembly.
        /// </summary>
        /// <param name="testIds">test ids</param>
        public void DeclareTestsFailingAtInit(params int[] testIds) => DeclareTestsFailingWhenTestingMutant(InitialRunId, testIds);
        
        /// <summary>
        /// Define optimization mode
        /// </summary>
        /// <param name="mode"></param>
        public void SetMode(OptimizationModes mode) => _mode = mode;

        /// <summary>
        /// Declare the tests that are failing when testing a mutant.
        /// </summary>
        /// <param name="mutantId">Mutant id</param>
        /// <param name="testIds">Test(s) failing for this mutant</param>
        public void DeclareTestsFailingWhenTestingMutant(int mutantId, params int[] testIds)
            {
            var testsGuidList = GetGuidList(testIds);
            // just check we are not doing something stupid
            if (mutantId!= InitialRunId && !testsGuidList.IsIncludedIn(GetCoveringTests(mutantId)))
            {
                throw new ApplicationException(
                    $"you tried to declare a failing test but it does not cover mutant {mutantId}");
            }
            _failedTestsPerMutant[mutantId] = testsGuidList;
        }

        /// <summary>
        /// Declare tests that fail for a specific run.
        /// </summary>
        /// <param name="mutantId">mutant concerned by those tests</param>
        /// <param name="mutantInRun"></param>
        /// <param name="failingTestIds"></param>
        /// <remarks>this method simulates interdependent tests</remarks>
        public void DeclareTestsFailingWhenTestingMutantWithGroup(int mutantId, IEnumerable<int> mutantInRun,
            params int[] failingTestIds)
        {
            var key = mutantInRun.ToHashSet();
            var testsGuidList = GetGuidList(failingTestIds);

            if (!_failedTestsPerRun.ContainsKey(key))
            {
                _failedTestsPerRun[key] = new Dictionary<int, TestGuidsList>();
            }
            _failedTestsPerRun[key][mutantId] = testsGuidList;
        }

        /// <summary>
        /// Create a test
        /// </summary>
        /// <param name="testId"></param>
        /// <param name="name"></param>
        /// <param name="file"></param>
        /// <returns></returns>
        public TestDescription CreateTest(int testId = -1, string name = null, string file = "TestFile.cs")
        {
            if (testId == -1)
            {
                testId = _tests.Keys.Append(-1).Max()+1;
            }

            var test = new TestDescription(Guid.NewGuid(), name ?? $"test {testId}", file);
            _tests[testId] = test;
            TestSet.RegisterTests(new[] { test });
            return test;
        }

        /// <summary>
        /// Create tests.
        /// </summary>
        /// <param name="testIds">List of ids to create test out of.</param>
        public void CreateTests(params int[] testIds)
        {
            foreach (var id in testIds)
            {
                CreateTest(id);
            }
        }

        /// <summary>
        /// Returns a list of test Guids
        /// </summary>
        /// <param name="testIds"></param>
        /// <returns></returns>
        public TestGuidsList GetGuidList(params int[] testIds) => new(testIds.Select(i => _tests[i]).Select(t => t.Id));

        private TestGuidsList GetGuidList() => new(_tests.Values.Select(t => t.Id));

        private TestGuidsList GetFailedTests(int mutantId, IEnumerable<int> readOnlyList)
        {
            if (readOnlyList != null)
            {
                var mutantIds = readOnlyList.ToHashSet();
                if (_failedTestsPerRun.ContainsKey(mutantIds))
                {
                    if (_failedTestsPerRun[mutantIds].TryGetValue(mutantId, out var list1))
                    {
                        return list1;
                    }
                }
            }

            if (_failedTestsPerMutant.TryGetValue(mutantId, out var list))
            {
                return list;
            }
            return TestGuidsList.NoTest();
        }

        private TestGuidsList GetCoveringTests(int mutantId)
        {
            if (mutantId == InitialRunId)
            {
                return GetGuidList();
            }
            
            if (!_mode.HasFlag(OptimizationModes.CoverageBasedTest))
            {
                return TestGuidsList.EveryTest();
            }

            if (_coverageResult.TryGetValue(mutantId, out var list))
            {
                return list;
            }
            
            return TestGuidsList.NoTest();
        }

        private TestRunResult GetRunResult(int id) =>
            new(GetCoveringTests(id), GetFailedTests(id, null), TestGuidsList.NoTest(), string.Empty,
                TimeSpan.Zero);

        public TestRunResult GetInitialRunResult() => GetRunResult(InitialRunId);

        public Mock<ITestRunner> GetTestRunnerMock()
        {
            if (_runnerMock != null)
            {
                return _runnerMock;
            }

            _runnerMock = new Mock<ITestRunner>();
            var successResult = new TestRunResult(GetGuidList(),
                TestGuidsList.NoTest(),
                TestGuidsList.NoTest(),
                string.Empty,
                TimeSpan.Zero);
            _runnerMock.Setup(x => x.DiscoverTests()).Returns(TestSet);
            _runnerMock.Setup(x => x.InitialTest()).Returns(GetRunResult(InitialRunId));
            _runnerMock.Setup(x => x.CaptureCoverage())
                .Returns(() =>
                {
                    var result = new List<CoverageRunResult>(_tests.Count);
                    foreach (var (guid, mutations) in _testCoverage)
                    {
                        result.Add(new CoverageRunResult(guid, CoverageConfidence.Normal,
                            mutations,
                            Enumerable.Empty<int>(),
                            Enumerable.Empty<int>()));
                    }
                    return result;
                });
            
            _runnerMock.Setup(x => x.TestMultipleMutants(It.IsAny<ITimeoutValueCalculator>(),
                    It.IsAny<IReadOnlyList<Mutant>>(), It.IsAny<TestUpdateHandler>())).
                Callback((Action<ITimeoutValueCalculator, IReadOnlyList<Mutant>, TestUpdateHandler>)((test1, list,
                    update) =>
                {
                    var ids = list.Select(m => m.Id);
                    foreach (var mutant in list)
                    {
                        update(list, GetFailedTests(mutant.Id, ids), mutant.AssessingTests, TestGuidsList.NoTest());
                    }
                }))
                .Returns(successResult);
            return _runnerMock;
        }


        private class HashSetComparer : IEqualityComparer<HashSet<int>>
        {
            public bool Equals(HashSet<int> x, HashSet<int> y) => x!= null && y!= null && x.SetEquals(y);

            public int GetHashCode([DisallowNull] HashSet<int> obj) => obj.Aggregate(0, (current, entry) => current ^ entry.GetHashCode());
        }

        public IEnumerable<Mutant> GetMutants() => Mutants.Values;
    }
}
